import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { distinctUntilChanged, map, combineLatest, debounceTime } from 'rxjs/operators';
import { OptionsService } from '../common/options.service';
import { StateService } from '../common/state-service.abstract';
import { NavigatorService } from '../navigator/navigator.service';
import * as i0 from "@angular/core";
import * as i1 from "../navigator/navigator.service";
import * as i2 from "../common/options.service";
/**
 * A service which defines header functions.
 */
let HeaderService = class HeaderService extends StateService {
    constructor(navigatorService, options) {
        super();
        this.navigatorService = navigatorService;
        this.options = options;
        this.hasItemsInNavigator$ = this.navigatorService.items$.pipe(map(({ length }) => !!length), distinctUntilChanged());
        this.state$ = new BehaviorSubject({
            title: undefined,
            nav: {
                open: false
            }
        });
        this.title = undefined;
        this.header$ = this.map((header) => header);
        this.navigatorOpen$ = this.map(({ nav }) => nav.open).pipe(combineLatest(this.hasItemsInNavigator$), map(([open, hasItems]) => open && hasItems));
        const titleReference = document.querySelector('title');
        this.title = {
            elementRef: titleReference,
            originalValue: titleReference && titleReference.innerText
        };
    }
    get state() {
        return this.state$.value;
    }
    get navigatorHiddenOnStartup() {
        return this.options.hideNavigator;
    }
    get largeWidth() {
        return document.documentElement.clientWidth > 1200;
    }
    get shouldToggle() {
        return this.largeWidth && !this.navigatorHiddenOnStartup && !this.state.nav.open;
    }
    /**
     * Toggles the navigator open status.
     */
    toggleNavigator() {
        this.state.nav.open = !this.state.nav.open;
        this.emitNewState();
    }
    /**
     * Force to close the navigator.
     */
    closeNavigator() {
        this.state.nav.open = false;
        this.emitNewState();
    }
    /**
     * Configures navigation options.
     * @param config Object with the properties:
     * - open: Boolean
     */
    configNavigator(config = {}) {
        this.state.nav = Object.assign(this.state.nav, config);
        this.emitNewState();
    }
    /**
     * Change the application title.
     * @param newTitle The new title of the application.
     */
    changeTitle(newTitle) {
        this.state.title = newTitle;
        this.emitNewState();
    }
    /**
     * Change the page title.
     * @param newTitle The new title of the page.
     */
    changePageTitle(newTitle) {
        this.title.elementRef.innerText = newTitle
            ? `${newTitle} / ${this.title.originalValue}`
            : `${this.title.originalValue}`;
    }
    /**
     * This methods checks if the navigator toggles on startup
     * or if an item is added to the navigator node.
     * Delay of 300ms is intended for animation purpose.
     */
    verifyIfNavOpen() {
        this.hasItemsInNavigator$
            .pipe(debounceTime(300))
            .subscribe(hasItems => hasItems && this.shouldToggle && this.toggleNavigator());
    }
    shouldShowBreadcrumbs() {
        return this.options.breadcrumbs;
    }
};
HeaderService.ctorParameters = () => [
    { type: NavigatorService },
    { type: OptionsService }
];
HeaderService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function HeaderService_Factory() { return new HeaderService(i0.ɵɵinject(i1.NavigatorService), i0.ɵɵinject(i2.OptionsService)); }, token: HeaderService, providedIn: "root" });
HeaderService = tslib_1.__decorate([
    Injectable({
        providedIn: 'root'
    })
], HeaderService);
export { HeaderService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVhZGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYzh5L25neC1jb21wb25lbnRzLyIsInNvdXJjZXMiOlsiY29yZS9oZWFkZXIvaGVhZGVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGVBQWUsRUFBa0IsTUFBTSxNQUFNLENBQUM7QUFDdkQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEYsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzNELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUNoRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQzs7OztBQUdsRTs7R0FFRztBQUlILElBQWEsYUFBYSxHQUExQixNQUFhLGFBQWMsU0FBUSxZQUFZO0lBa0I3QyxZQUFvQixnQkFBa0MsRUFBVSxPQUF1QjtRQUNyRixLQUFLLEVBQUUsQ0FBQztRQURVLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFBVSxZQUFPLEdBQVAsT0FBTyxDQUFnQjtRQWR2Rix5QkFBb0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDdEQsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUM3QixvQkFBb0IsRUFBRSxDQUN2QixDQUFDO1FBRUYsV0FBTSxHQUE0QixJQUFJLGVBQWUsQ0FBUztZQUM1RCxLQUFLLEVBQUUsU0FBUztZQUNoQixHQUFHLEVBQUU7Z0JBQ0gsSUFBSSxFQUFFLEtBQUs7YUFDWjtTQUNGLENBQUMsQ0FBQztRQUVILFVBQUssR0FBRyxTQUFTLENBQUM7UUFJaEIsSUFB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RCxxQkFBcUI7UUFDbkIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQztJQUNsQyxDQUFDO0NBQ0YsQ0FBQTs7WUF6RnVDLGdCQUFnQjtZQUFtQixjQUFjOzs7QUFsQjVFLGFBQWE7SUFIekIsVUFBVSxDQUFDO1FBQ1YsVUFBVSxFQUFFLE1BQU07S0FDbkIsQ0FBQztHQUNXLGFBQWEsQ0EyR3pCO1NBM0dZLGFBQWEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwLCBjb21iaW5lTGF0ZXN0LCBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBPcHRpb25zU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9vcHRpb25zLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3N0YXRlLXNlcnZpY2UuYWJzdHJhY3QnO1xuaW1wb3J0IHsgTmF2aWdhdG9yU2VydmljZSB9IGZyb20gJy4uL25hdmlnYXRvci9uYXZpZ2F0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBIZWFkZXIgfSBmcm9tICcuL2hlYWRlci5tb2RlbCc7XG5cbi8qKlxuICogQSBzZXJ2aWNlIHdoaWNoIGRlZmluZXMgaGVhZGVyIGZ1bmN0aW9ucy5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgSGVhZGVyU2VydmljZSBleHRlbmRzIFN0YXRlU2VydmljZSB7XG4gIGhlYWRlciQ6IE9ic2VydmFibGU8SGVhZGVyPjtcbiAgbmF2aWdhdG9yT3BlbiQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgaGFzSXRlbXNJbk5hdmlnYXRvciQgPSB0aGlzLm5hdmlnYXRvclNlcnZpY2UuaXRlbXMkLnBpcGUoXG4gICAgbWFwKCh7IGxlbmd0aCB9KSA9PiAhIWxlbmd0aCksXG4gICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICApO1xuXG4gIHN0YXRlJDogQmVoYXZpb3JTdWJqZWN0PEhlYWRlcj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEhlYWRlcj4oe1xuICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgbmF2OiB7XG4gICAgICBvcGVuOiBmYWxzZVxuICAgIH1cbiAgfSk7XG5cbiAgdGl0bGUgPSB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuYXZpZ2F0b3JTZXJ2aWNlOiBOYXZpZ2F0b3JTZXJ2aWNlLCBwcml2YXRlIG9wdGlvbnM6IE9wdGlvbnNTZXJ2aWNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmhlYWRlciQgPSB0aGlzLm1hcCgoaGVhZGVyOiBIZWFkZXIpID0+IGhlYWRlcik7XG4gICAgdGhpcy5uYXZpZ2F0b3JPcGVuJCA9IHRoaXMubWFwKCh7IG5hdiB9KSA9PiBuYXYub3BlbikucGlwZShcbiAgICAgIGNvbWJpbmVMYXRlc3QodGhpcy5oYXNJdGVtc0luTmF2aWdhdG9yJCksXG4gICAgICBtYXAoKFtvcGVuLCBoYXNJdGVtc10pID0+IG9wZW4gJiYgaGFzSXRlbXMpXG4gICAgKTtcbiAgICBjb25zdCB0aXRsZVJlZmVyZW5jZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RpdGxlJyk7XG4gICAgdGhpcy50aXRsZSA9IHtcbiAgICAgIGVsZW1lbnRSZWY6IHRpdGxlUmVmZXJlbmNlLFxuICAgICAgb3JpZ2luYWxWYWx1ZTogdGl0bGVSZWZlcmVuY2UgJiYgdGl0bGVSZWZlcmVuY2UuaW5uZXJUZXh0XG4gICAgfTtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSQudmFsdWU7XG4gIH1cblxuICBnZXQgbmF2aWdhdG9ySGlkZGVuT25TdGFydHVwKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaGlkZU5hdmlnYXRvcjtcbiAgfVxuXG4gIGdldCBsYXJnZVdpZHRoKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPiAxMjAwO1xuICB9XG5cbiAgZ2V0IHNob3VsZFRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXJnZVdpZHRoICYmICF0aGlzLm5hdmlnYXRvckhpZGRlbk9uU3RhcnR1cCAmJiAhdGhpcy5zdGF0ZS5uYXYub3BlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBuYXZpZ2F0b3Igb3BlbiBzdGF0dXMuXG4gICAqL1xuICB0b2dnbGVOYXZpZ2F0b3IoKSB7XG4gICAgdGhpcy5zdGF0ZS5uYXYub3BlbiA9ICF0aGlzLnN0YXRlLm5hdi5vcGVuO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgdG8gY2xvc2UgdGhlIG5hdmlnYXRvci5cbiAgICovXG4gIGNsb3NlTmF2aWdhdG9yKCkge1xuICAgIHRoaXMuc3RhdGUubmF2Lm9wZW4gPSBmYWxzZTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgbmF2aWdhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0gY29uZmlnIE9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzOlxuICAgKiAtIG9wZW46IEJvb2xlYW5cbiAgICovXG4gIGNvbmZpZ05hdmlnYXRvcihjb25maWc6IGFueSA9IHt9KSB7XG4gICAgdGhpcy5zdGF0ZS5uYXYgPSBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUubmF2LCBjb25maWcpO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBhcHBsaWNhdGlvbiB0aXRsZS5cbiAgICogQHBhcmFtIG5ld1RpdGxlIFRoZSBuZXcgdGl0bGUgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgY2hhbmdlVGl0bGUobmV3VGl0bGU/OiBhbnkpIHtcbiAgICB0aGlzLnN0YXRlLnRpdGxlID0gbmV3VGl0bGU7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIHBhZ2UgdGl0bGUuXG4gICAqIEBwYXJhbSBuZXdUaXRsZSBUaGUgbmV3IHRpdGxlIG9mIHRoZSBwYWdlLlxuICAgKi9cbiAgY2hhbmdlUGFnZVRpdGxlKG5ld1RpdGxlPzogc3RyaW5nKSB7XG4gICAgdGhpcy50aXRsZS5lbGVtZW50UmVmLmlubmVyVGV4dCA9IG5ld1RpdGxlXG4gICAgICA/IGAke25ld1RpdGxlfSAvICR7dGhpcy50aXRsZS5vcmlnaW5hbFZhbHVlfWBcbiAgICAgIDogYCR7dGhpcy50aXRsZS5vcmlnaW5hbFZhbHVlfWA7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIGNoZWNrcyBpZiB0aGUgbmF2aWdhdG9yIHRvZ2dsZXMgb24gc3RhcnR1cFxuICAgKiBvciBpZiBhbiBpdGVtIGlzIGFkZGVkIHRvIHRoZSBuYXZpZ2F0b3Igbm9kZS5cbiAgICogRGVsYXkgb2YgMzAwbXMgaXMgaW50ZW5kZWQgZm9yIGFuaW1hdGlvbiBwdXJwb3NlLlxuICAgKi9cbiAgdmVyaWZ5SWZOYXZPcGVuKCkge1xuICAgIHRoaXMuaGFzSXRlbXNJbk5hdmlnYXRvciRcbiAgICAgIC5waXBlKGRlYm91bmNlVGltZSgzMDApKVxuICAgICAgLnN1YnNjcmliZShoYXNJdGVtcyA9PiBoYXNJdGVtcyAmJiB0aGlzLnNob3VsZFRvZ2dsZSAmJiB0aGlzLnRvZ2dsZU5hdmlnYXRvcigpKTtcbiAgfVxuXG4gIHNob3VsZFNob3dCcmVhZGNydW1icygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJyZWFkY3J1bWJzO1xuICB9XG59XG4iXX0=