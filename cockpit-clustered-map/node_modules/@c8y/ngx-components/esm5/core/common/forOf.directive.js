import * as tslib_1 from "tslib";
import { ComponentFactory, ComponentFactoryResolver, Directive, Input, TemplateRef, ViewContainerRef, SimpleChanges } from '@angular/core';
import { isObservable, of, pipe } from 'rxjs';
import { map, tap } from 'rxjs/operators';
import { LoadMoreComponent } from './load-more.component';
import { assign } from 'lodash-es';
/**
 * A directive to iterate over IResultList<T> data from @c8y/client.
 * Depending on the [c8yForLoadMore] a load more button is:
 *  - auto: Tries to automatically load more data (default maximum 10 iterations; can be
 *          change with maxIterations settings).
 *  - show: Shows a load more button for the user to decide
 *  - none: Doesn't perform any load more action.
 *  - hidden: Loads more data automatically but with no visible button for the user.
 *
 * Additional, any rxjs operator pipe can be applied to the [c8yForPipe] input, e.g. to
 * filter the data displayed currently as well as the data loaded by subsequent requests.
 *
 * Example:
 * ```html
 * <div *c8yFor="let device of devices; loadMore: 'auto'; let i = index; pipe: filterPipe;">
 *  {{ i + 1 }}. {{device.name}}
 * </div>
 * ```
 * The above example will list all entities that are applied to `devices`:
 * ```typescript
 * this.devices = this.inventoryService.list({ pageSize: 10, fragmentType: 'c8y_IsDevice' })
 * ```
 * It will display the first 10 items, if there is more space left on the screen, and there are more
 * than 10 devices, it will automatically load up to 10 pages more. If it still can't fit the screen
 * it will stop and switch to `show` mode.
 *
 * A pipe can be applied e.g. for filtering or grouping. This pipe is attached to every follow up
 * request done by the load more component:
 * ```typescript
 * this.filterPipe = pipe(
 *    map((data: []) => {
 *     return data.filter(
 *      (mo: any) => mo.name && mo.name.toLowerCase().indexOf(value.toLowerCase()) > -1
 *    );
 *  })
 * );
 * ```
 * The pipe must be an rxjs pipe and can take any operator.
 */
var ForOfDirective = /** @class */ (function () {
    function ForOfDirective(tpl, vcr, componentFactoryResolver) {
        this.tpl = tpl;
        this.vcr = vcr;
        this.componentFactoryResolver = componentFactoryResolver;
        this.cachedData = [];
        this.loadMoreMode = 'auto';
        this.dataPipe = pipe(tap());
        this.maxIterations = 10;
    }
    Object.defineProperty(ForOfDirective.prototype, "shouldUseLoadMoreButton", {
        get: function () {
            return (this.loadMoreMode === 'auto' || this.loadMoreMode === 'show' || this.loadMoreMode === 'hidden');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForOfDirective.prototype, "hasMoreData", {
        get: function () {
            return this.loadMore && this.loadMore.hasMore;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForOfDirective.prototype, "length", {
        get: function () {
            return this.cachedData.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForOfDirective.prototype, "c8yForOf", {
        /**
         * The data setter. Must be a response from @c8y/data or a observable.
         */
        set: function (fetchData) {
            var _this = this;
            if (fetchData) {
                this.obs$ = (isObservable(fetchData) ? fetchData : of(fetchData)).pipe(map(function (result) {
                    var paging = result.paging, data = result.data;
                    _this.paging = paging;
                    return data;
                }));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForOfDirective.prototype, "c8yForLoadMore", {
        /**
         * The mode setter:
         *  - auto: Tries to automatically load more data (default maximum 10 iterations; can be
         *          change with maxIterations settings).
         *  - show: Shows a load more button for the user to decide
         *  - none: Doesn't perform any load more action.
         *  - hidden: Loads more data automatically but with no visible button for the user.
         */
        set: function (type) {
            this.loadMoreMode = type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForOfDirective.prototype, "c8yForPipe", {
        /**
         * The pipe setter to attach any rxjs pipe to the current and more loaded data.
         */
        set: function (dataPipe) {
            if (dataPipe) {
                this.dataPipe = dataPipe;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForOfDirective.prototype, "c8yForNotFound", {
        /**
         * A template to use if no data is found at all (e.g. if you apply a filter pipe).
         */
        set: function (notFoundTemplate) {
            this.notFoundTemplate = notFoundTemplate;
            if (this.loadMore) {
                this.loadMore.noMoreDataHint = notFoundTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForOfDirective.prototype, "c8yForMaxIterations", {
        /**
         * The maximum numbers of iterations to call data from the api.
         */
        set: function (maxIterations) {
            this.maxIterations = maxIterations;
        },
        enumerable: true,
        configurable: true
    });
    ForOfDirective.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (this.obs$ && (changes.c8yForPipe || changes.c8yForOf)) {
            this.unsubscribePaging();
            // only re-rendering  on filtering if all data is already loaded
            // from the backend
            var reRender_1 = !this.hasMoreData && !!changes.c8yForPipe && !changes.c8yForOf;
            if (reRender_1) {
                this.obs$ = of(this.cachedData);
            }
            this.pagingSub = this.obs$
                .pipe(tap(function (data) {
                if (!reRender_1) {
                    _this.cachedData = data;
                }
            }))
                .pipe(function (src) { return _this.dataPipe(src); })
                .subscribe(function (data) {
                _this.render(data, reRender_1);
            });
        }
    };
    ForOfDirective.prototype.ngOnDestroy = function () {
        this.unsubscribePaging();
    };
    ForOfDirective.prototype.render = function (data, reRender) {
        var _this = this;
        if (reRender === void 0) { reRender = false; }
        this.vcr.clear();
        data.forEach(function (item, index) {
            var context = {
                $implicit: item,
                index: index,
                length: _this.length,
                hasMore: _this.hasMoreData
            };
            _this.vcr.createEmbeddedView(_this.tpl, context);
        });
        if (this.shouldUseLoadMoreButton) {
            this.loadMore = this.createLoadMoreButtonComponent(reRender);
        }
    };
    ForOfDirective.prototype.append = function (data) {
        var _this = this;
        data.forEach(function (item) {
            var index = _this.shouldUseLoadMoreButton ? _this.vcr.length - 1 : _this.vcr.length;
            var context = {
                $implicit: item,
                index: index,
                length: _this.length,
                hasMore: _this.hasMoreData
            };
            _this.vcr.createEmbeddedView(_this.tpl, context, index);
        });
    };
    ForOfDirective.prototype.loadMoreData = function (data) {
        if (data.length > 0) {
            this.append(data);
        }
    };
    ForOfDirective.prototype.createLoadMoreButtonComponent = function (reRender) {
        var _this = this;
        var componentFactory = this.componentFactoryResolver.resolveComponentFactory(LoadMoreComponent);
        var componentRef = this.vcr.createComponent(componentFactory);
        var instance = componentRef.instance;
        instance.paging = this.paging;
        instance.useIntersection = this.loadMoreMode === 'auto' || this.loadMoreMode === 'hidden';
        instance.hidden = this.loadMoreMode === 'hidden';
        instance.maxIterations = this.maxIterations;
        instance.noMoreDataHint = this.notFoundTemplate;
        this.pagingSub = instance.onLoad
            .pipe(tap(function (data) {
            _this.cachedData = _this.cachedData.concat(data);
        }))
            .pipe(function (src) { return _this.dataPipe(src); })
            .subscribe(function (data) { return _this.loadMoreData(data); });
        if (reRender) {
            assign(instance, this.loadMore);
        }
        return instance;
    };
    ForOfDirective.prototype.unsubscribePaging = function () {
        if (this.pagingSub) {
            this.pagingSub.unsubscribe();
        }
    };
    ForOfDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: ComponentFactoryResolver }
    ]; };
    tslib_1.__decorate([
        Input()
    ], ForOfDirective.prototype, "c8yForOf", null);
    tslib_1.__decorate([
        Input()
    ], ForOfDirective.prototype, "c8yForLoadMore", null);
    tslib_1.__decorate([
        Input()
    ], ForOfDirective.prototype, "c8yForPipe", null);
    tslib_1.__decorate([
        Input()
    ], ForOfDirective.prototype, "c8yForNotFound", null);
    tslib_1.__decorate([
        Input()
    ], ForOfDirective.prototype, "c8yForMaxIterations", null);
    ForOfDirective = tslib_1.__decorate([
        Directive({
            selector: '[c8yFor]'
        })
    ], ForOfDirective);
    return ForOfDirective;
}());
export { ForOfDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yT2YuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGM4eS9uZ3gtY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbImNvcmUvY29tbW9uL2Zvck9mLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLGdCQUFnQixFQUNoQix3QkFBd0IsRUFDeEIsU0FBUyxFQUNULEtBQUssRUFDTCxXQUFXLEVBQ1gsZ0JBQWdCLEVBQ2hCLGFBQWEsRUFDZCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsWUFBWSxFQUFjLEVBQUUsRUFBRSxJQUFJLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUVuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQ0c7QUFJSDtJQW1GRSx3QkFDVSxHQUFxQixFQUNyQixHQUFxQixFQUNyQix3QkFBa0Q7UUFGbEQsUUFBRyxHQUFILEdBQUcsQ0FBa0I7UUFDckIsUUFBRyxHQUFILEdBQUcsQ0FBa0I7UUFDckIsNkJBQXdCLEdBQXhCLHdCQUF3QixDQUEwQjtRQXJGcEQsZUFBVSxHQUFHLEVBQUUsQ0FBQztRQUVoQixpQkFBWSxHQUF3QyxNQUFNLENBQUM7UUFDM0QsYUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBSXZCLGtCQUFhLEdBQUcsRUFBRSxDQUFDO0lBK0V4QixDQUFDO0lBNUVKLHNCQUFZLG1EQUF1QjthQUFuQztZQUNFLE9BQU8sQ0FDTCxJQUFJLENBQUMsWUFBWSxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsWUFBWSxL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LE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqRCxDQUFDLENBQUMsQ0FDSDthQUNBLElBQUksQ0FBQyxVQUFBLEdBQUcsSUFBSSxPQUFBLEtBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQWxCLENBQWtCLENBQUM7YUFDL0IsU0FBUyxDQUFDLFVBQUEsSUFBSSxJQUFJLE9BQUEsS0FBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBdkIsQ0FBdUIsQ0FBQyxDQUFDO1FBQzlDLElBQUksUUFBUSxFQUFFO1lBQ1osTUFBTSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDakM7UUFDRCxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRU8sMENBQWlCLEdBQXpCO1FBQ0UsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDOUI7SUFDSCxDQUFDOztnQkFyR2MsV0FBVztnQkFDWCxnQkFBZ0I7Z0JBQ0ssd0JBQXdCOztJQXpENUQ7UUFEQyxLQUFLLEVBQUU7a0RBV1A7SUFXRDtRQURDLEtBQUssRUFBRTt3REFHUDtJQU1EO1FBREMsS0FBSyxFQUFFO29EQUtQO0lBTUQ7UUFEQyxLQUFLLEVBQUU7d0RBTVA7SUFNRDtRQURDLEtBQUssRUFBRTs2REFHUDtJQWpGVSxjQUFjO1FBSDFCLFNBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxVQUFVO1NBQ3JCLENBQUM7T0FDVyxjQUFjLENBMEwxQjtJQUFELHFCQUFDO0NBQUEsQUExTEQsSUEwTEM7U0ExTFksY0FBYyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudEZhY3RvcnksXG4gIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgRGlyZWN0aXZlLFxuICBJbnB1dCxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJSWRlbnRpZmllZCwgSVJlc3VsdExpc3QsIFBhZ2luZyB9IGZyb20gJ0BjOHkvY2xpZW50JztcbmltcG9ydCB7IGlzT2JzZXJ2YWJsZSwgT2JzZXJ2YWJsZSwgb2YsIHBpcGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBMb2FkTW9yZUNvbXBvbmVudCB9IGZyb20gJy4vbG9hZC1tb3JlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdsb2Rhc2gtZXMnO1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRvIGl0ZXJhdGUgb3ZlciBJUmVzdWx0TGlzdDxUPiBkYXRhIGZyb20gQGM4eS9jbGllbnQuXG4gKiBEZXBlbmRpbmcgb24gdGhlIFtjOHlGb3JMb2FkTW9yZV0gYSBsb2FkIG1vcmUgYnV0dG9uIGlzOlxuICogIC0gYXV0bzogVHJpZXMgdG8gYXV0b21hdGljYWxseSBsb2FkIG1vcmUgZGF0YSAoZGVmYXVsdCBtYXhpbXVtIDEwIGl0ZXJhdGlvbnM7IGNhbiBiZVxuICogICAgICAgICAgY2hhbmdlIHdpdGggbWF4SXRlcmF0aW9ucyBzZXR0aW5ncykuXG4gKiAgLSBzaG93OiBTaG93cyBhIGxvYWQgbW9yZSBidXR0b24gZm9yIHRoZSB1c2VyIHRvIGRlY2lkZVxuICogIC0gbm9uZTogRG9lc24ndCBwZXJmb3JtIGFueSBsb2FkIG1vcmUgYWN0aW9uLlxuICogIC0gaGlkZGVuOiBMb2FkcyBtb3JlIGRhdGEgYXV0b21hdGljYWxseSBidXQgd2l0aCBubyB2aXNpYmxlIGJ1dHRvbiBmb3IgdGhlIHVzZXIuXG4gKlxuICogQWRkaXRpb25hbCwgYW55IHJ4anMgb3BlcmF0b3IgcGlwZSBjYW4gYmUgYXBwbGllZCB0byB0aGUgW2M4eUZvclBpcGVdIGlucHV0LCBlLmcuIHRvXG4gKiBmaWx0ZXIgdGhlIGRhdGEgZGlzcGxheWVkIGN1cnJlbnRseSBhcyB3ZWxsIGFzIHRoZSBkYXRhIGxvYWRlZCBieSBzdWJzZXF1ZW50IHJlcXVlc3RzLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8ZGl2ICpjOHlGb3I9XCJsZXQgZGV2aWNlIG9mIGRldmljZXM7IGxvYWRNb3JlOiAnYXV0byc7IGxldCBpID0gaW5kZXg7IHBpcGU6IGZpbHRlclBpcGU7XCI+XG4gKiAge3sgaSArIDEgfX0uIHt7ZGV2aWNlLm5hbWV9fVxuICogPC9kaXY+XG4gKiBgYGBcbiAqIFRoZSBhYm92ZSBleGFtcGxlIHdpbGwgbGlzdCBhbGwgZW50aXRpZXMgdGhhdCBhcmUgYXBwbGllZCB0byBgZGV2aWNlc2A6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiB0aGlzLmRldmljZXMgPSB0aGlzLmludmVudG9yeVNlcnZpY2UubGlzdCh7IHBhZ2VTaXplOiAxMCwgZnJhZ21lbnRUeXBlOiAnYzh5X0lzRGV2aWNlJyB9KVxuICogYGBgXG4gKiBJdCB3aWxsIGRpc3BsYXkgdGhlIGZpcnN0IDEwIGl0ZW1zLCBpZiB0aGVyZSBpcyBtb3JlIHNwYWNlIGxlZnQgb24gdGhlIHNjcmVlbiwgYW5kIHRoZXJlIGFyZSBtb3JlXG4gKiB0aGFuIDEwIGRldmljZXMsIGl0IHdpbGwgYXV0b21hdGljYWxseSBsb2FkIHVwIHRvIDEwIHBhZ2VzIG1vcmUuIElmIGl0IHN0aWxsIGNhbid0IGZpdCB0aGUgc2NyZWVuXG4gKiBpdCB3aWxsIHN0b3AgYW5kIHN3aXRjaCB0byBgc2hvd2AgbW9kZS5cbiAqXG4gKiBBIHBpcGUgY2FuIGJlIGFwcGxpZWQgZS5nLiBmb3IgZmlsdGVyaW5nIG9yIGdyb3VwaW5nLiBUaGlzIHBpcGUgaXMgYXR0YWNoZWQgdG8gZXZlcnkgZm9sbG93IHVwXG4gKiByZXF1ZXN0IGRvbmUgYnkgdGhlIGxvYWQgbW9yZSBjb21wb25lbnQ6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiB0aGlzLmZpbHRlclBpcGUgPSBwaXBlKFxuICogICAgbWFwKChkYXRhOiBbXSkgPT4ge1xuICogICAgIHJldHVybiBkYXRhLmZpbHRlcihcbiAqICAgICAgKG1vOiBhbnkpID0+IG1vLm5hbWUgJiYgbW8ubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgPiAtMVxuICogICAgKTtcbiAqICB9KVxuICogKTtcbiAqIGBgYFxuICogVGhlIHBpcGUgbXVzdCBiZSBhbiByeGpzIHBpcGUgYW5kIGNhbiB0YWtlIGFueSBvcGVyYXRvci5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2M4eUZvcl0nXG59KVxuZXhwb3J0IGNsYXNzIEZvck9mRGlyZWN0aXZlIHtcbiAgcHJpdmF0ZSBjYWNoZWREYXRhID0gW107XG4gIHByaXZhdGUgcGFnaW5nOiBQYWdpbmc8SUlkZW50aWZpZWQ+O1xuICBwcml2YXRlIGxvYWRNb3JlTW9kZTogJ2F1dG8nIHwgJ3Nob3cnIHwgJ25vbmUnIHwgJ2hpZGRlbicgPSAnYXV0byc7XG4gIHByaXZhdGUgZGF0YVBpcGUgPSBwaXBlKHRhcCgpKTtcbiAgcHJpdmF0ZSBwYWdpbmdTdWI6IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBvYnMkOiBPYnNlcnZhYmxlPElJZGVudGlmaWVkW10+O1xuICBwcml2YXRlIGxvYWRNb3JlOiBMb2FkTW9yZUNvbXBvbmVudDtcbiAgcHJpdmF0ZSBtYXhJdGVyYXRpb25zID0gMTA7XG4gIHByaXZhdGUgbm90Rm91bmRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICBwcml2YXRlIGdldCBzaG91bGRVc2VMb2FkTW9yZUJ1dHRvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2FkTW9yZU1vZGUgPT09ICdhdXRvJyB8fCB0aGlzLmxvYWRNb3JlTW9kZSA9PT0gJ3Nob3cnIHx8IHRoaXMubG9hZE1vcmVNb2RlID09PSAnaGlkZGVuJ1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGdldCBoYXNNb3JlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkTW9yZSAmJiB0aGlzLmxvYWRNb3JlLmhhc01vcmU7XG4gIH1cblxuICBwcml2YXRlIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkRGF0YS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRhdGEgc2V0dGVyLiBNdXN0IGJlIGEgcmVzcG9uc2UgZnJvbSBAYzh5L2RhdGEgb3IgYSBvYnNlcnZhYmxlLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGM4eUZvck9mKGZldGNoRGF0YTogSVJlc3VsdExpc3Q8SUlkZW50aWZpZWQ+IHwgT2JzZXJ2YWJsZTxJUmVzdWx0TGlzdDxJSWRlbnRpZmllZD4+KSB7XG4gICAgaWYgKGZldGNoRGF0YSkge1xuICAgICAgdGhpcy5vYnMkID0gKGlzT2JzZXJ2YWJsZShmZXRjaERhdGEpID8gZmV0Y2hEYXRhIDogb2YoZmV0Y2hEYXRhKSkucGlwZShcbiAgICAgICAgbWFwKHJlc3VsdCA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwYWdpbmcsIGRhdGEgfSA9IHJlc3VsdDtcbiAgICAgICAgICB0aGlzLnBhZ2luZyA9IHBhZ2luZztcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlIHNldHRlcjpcbiAgICogIC0gYXV0bzogVHJpZXMgdG8gYXV0b21hdGljYWxseSBsb2FkIG1vcmUgZGF0YSAoZGVmYXVsdCBtYXhpbXVtIDEwIGl0ZXJhdGlvbnM7IGNhbiBiZVxuICAgKiAgICAgICAgICBjaGFuZ2Ugd2l0aCBtYXhJdGVyYXRpb25zIHNldHRpbmdzKS5cbiAgICogIC0gc2hvdzogU2hvd3MgYSBsb2FkIG1vcmUgYnV0dG9uIGZvciB0aGUgdXNlciB0byBkZWNpZGVcbiAgICogIC0gbm9uZTogRG9lc24ndCBwZXJmb3JtIGFueSBsb2FkIG1vcmUgYWN0aW9uLlxuICAgKiAgLSBoaWRkZW46IExvYWRzIG1vcmUgZGF0YSBhdXRvbWF0aWNhbGx5IGJ1dCB3aXRoIG5vIHZpc2libGUgYnV0dG9uIGZvciB0aGUgdXNlci5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBjOHlGb3JMb2FkTW9yZSh0eXBlOiAnYXV0bycgfCAnc2hvdycgfCAnbm9uZScgfCAnaGlkZGVuJykge1xuICAgIHRoaXMubG9hZE1vcmVNb2RlID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcGlwZSBzZXR0ZXIgdG8gYXR0YWNoIGFueSByeGpzIHBpcGUgdG8gdGhlIGN1cnJlbnQgYW5kIG1vcmUgbG9hZGVkIGRhdGEuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgYzh5Rm9yUGlwZShkYXRhUGlwZSkge1xuICAgIGlmIChkYXRhUGlwZSkge1xuICAgICAgdGhpcy5kYXRhUGlwZSA9IGRhdGFQaXBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHRlbXBsYXRlIHRvIHVzZSBpZiBubyBkYXRhIGlzIGZvdW5kIGF0IGFsbCAoZS5nLiBpZiB5b3UgYXBwbHkgYSBmaWx0ZXIgcGlwZSkuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgYzh5Rm9yTm90Rm91bmQobm90Rm91bmRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge1xuICAgIHRoaXMubm90Rm91bmRUZW1wbGF0ZSA9IG5vdEZvdW5kVGVtcGxhdGU7XG4gICAgaWYgKHRoaXMubG9hZE1vcmUpIHtcbiAgICAgIHRoaXMubG9hZE1vcmUubm9Nb3JlRGF0YUhpbnQgPSBub3RGb3VuZFRlbXBsYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXJzIG9mIGl0ZXJhdGlvbnMgdG8gY2FsbCBkYXRhIGZyb20gdGhlIGFwaS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBjOHlGb3JNYXhJdGVyYXRpb25zKG1heEl0ZXJhdGlvbnM6IG51bWJlcikge1xuICAgIHRoaXMubWF4SXRlcmF0aW9ucyA9IG1heEl0ZXJhdGlvbnM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRwbDogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICkge31cblxuICBwcml2YXRlIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vYnMkICYmIChjaGFuZ2VzLmM4eUZvclBpcGUgfHwgY2hhbmdlcy5jOHlGb3JPZikpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmVQYWdpbmcoKTtcblxuICAgICAgLy8gb25seSByZS1yZW5kZXJpbmcgIG9uIGZpbHRlcmluZyBpZiBhbGwgZGF0YSBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgLy8gZnJvbSB0aGUgYmFja2VuZFxuICAgICAgY29uc3QgcmVSZW5kZXIgPSAhdGhpcy5oYXNNb3JlRGF0YSAmJiAhIWNoYW5nZXMuYzh5Rm9yUGlwZSAmJiAhY2hhbmdlcy5jOHlGb3JPZjtcblxuICAgICAgaWYgKHJlUmVuZGVyKSB7XG4gICAgICAgIHRoaXMub2JzJCA9IG9mKHRoaXMuY2FjaGVkRGF0YSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZ2luZ1N1YiA9IHRoaXMub2JzJFxuICAgICAgICAucGlwZShcbiAgICAgICAgICB0YXAoZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlUmVuZGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgICAucGlwZShzcmMgPT4gdGhpcy5kYXRhUGlwZShzcmMpKVxuICAgICAgICAuc3Vic2NyaWJlKChkYXRhOiBbXSkgPT4ge1xuICAgICAgICAgIHRoaXMucmVuZGVyKGRhdGEsIHJlUmVuZGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlUGFnaW5nKCk7XG4gIH1cblxuICBwcml2YXRlIHJlbmRlcihkYXRhLCByZVJlbmRlciA9IGZhbHNlKTogdm9pZCB7XG4gICAgdGhpcy52Y3IuY2xlYXIoKTtcblxuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICRpbXBsaWNpdDogaXRlbSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGhhc01vcmU6IHRoaXMuaGFzTW9yZURhdGFcbiAgICAgIH07XG4gICAgICB0aGlzLnZjci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50cGwsIGNvbnRleHQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkVXNlTG9hZE1vcmVCdXR0b24pIHtcbiAgICAgIHRoaXMubG9hZE1vcmUgPSB0aGlzLmNyZWF0ZUxvYWRNb3JlQnV0dG9uQ29tcG9uZW50KHJlUmVuZGVyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFwcGVuZChkYXRhKSB7XG4gICAgZGF0YS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnNob3VsZFVzZUxvYWRNb3JlQnV0dG9uID8gdGhpcy52Y3IubGVuZ3RoIC0gMSA6IHRoaXMudmNyLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICRpbXBsaWNpdDogaXRlbSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGhhc01vcmU6IHRoaXMuaGFzTW9yZURhdGFcbiAgICAgIH07XG4gICAgICB0aGlzLnZjci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50cGwsIGNvbnRleHQsIGluZGV4KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbG9hZE1vcmVEYXRhKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFwcGVuZChkYXRhKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUxvYWRNb3JlQnV0dG9uQ29tcG9uZW50KHJlUmVuZGVyKSB7XG4gICAgY29uc3QgY29tcG9uZW50RmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxcbiAgICAgIGFueVxuICAgID4gPSB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShMb2FkTW9yZUNvbXBvbmVudCk7XG4gICAgY29uc3QgY29tcG9uZW50UmVmID0gdGhpcy52Y3IuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudEZhY3RvcnkpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gY29tcG9uZW50UmVmLmluc3RhbmNlIGFzIExvYWRNb3JlQ29tcG9uZW50O1xuICAgIGluc3RhbmNlLnBhZ2luZyA9IHRoaXMucGFnaW5nO1xuICAgIGluc3RhbmNlLnVzZUludGVyc2VjdGlvbiA9IHRoaXMubG9hZE1vcmVNb2RlID09PSAnYXV0bycgfHwgdGhpcy5sb2FkTW9yZU1vZGUgPT09ICdoaWRkZW4nO1xuICAgIGluc3RhbmNlLmhpZGRlbiA9IHRoaXMubG9hZE1vcmVNb2RlID09PSAnaGlkZGVuJztcbiAgICBpbnN0YW5jZS5tYXhJdGVyYXRpb25zID0gdGhpcy5tYXhJdGVyYXRpb25zO1xuICAgIGluc3RhbmNlLm5vTW9yZURhdGFIaW50ID0gdGhpcy5ub3RGb3VuZFRlbXBsYXRlO1xuICAgIHRoaXMucGFnaW5nU3ViID0gaW5zdGFuY2Uub25Mb2FkXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKChkYXRhOiBbXSkgPT4ge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IHRoaXMuY2FjaGVkRGF0YS5jb25jYXQoZGF0YSk7XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICAucGlwZShzcmMgPT4gdGhpcy5kYXRhUGlwZShzcmMpKVxuICAgICAgLnN1YnNjcmliZShkYXRhID0+IHRoaXMubG9hZE1vcmVEYXRhKGRhdGEpKTtcbiAgICBpZiAocmVSZW5kZXIpIHtcbiAgICAgIGFzc2lnbihpbnN0YW5jZSwgdGhpcy5sb2FkTW9yZSk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgdW5zdWJzY3JpYmVQYWdpbmcoKSB7XG4gICAgaWYgKHRoaXMucGFnaW5nU3ViKSB7XG4gICAgICB0aGlzLnBhZ2luZ1N1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIl19