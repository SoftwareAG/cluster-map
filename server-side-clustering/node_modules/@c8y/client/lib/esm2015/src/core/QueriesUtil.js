export class QueriesUtil {
    constructor() {
        this.operatorFns = {
            __not: (operand) => {
                return ['not(', this.buildQueryFilter(operand, null), ')'].join('');
            },
            __and: (operand) => {
                return this.buildQueryFilter(operand, null, 'and');
            },
            __or: (operand) => {
                return this.buildQueryFilter(operand, null, 'or');
            },
            __eq: (operand, contextKey) => {
                if (typeof operand === 'object' && operand !== null) {
                    return this.buildQueryFilter(operand, contextKey);
                }
                return [contextKey, 'eq', this.quoteString(operand)].join(' ');
            },
            __gt: (operand, contextKey) => {
                return [contextKey, 'gt', this.quoteString(operand)].join(' ');
            },
            __ge: (operand, contextKey) => {
                return [contextKey, 'ge', this.quoteString(operand)].join(' ');
            },
            __lt: (operand, contextKey) => {
                return [contextKey, 'lt', this.quoteString(operand)].join(' ');
            },
            __le: (operand, contextKey) => {
                return [contextKey, 'le', this.quoteString(operand)].join(' ');
            },
            __in: (operand, contextKey) => {
                const stmts = operand.filter((op) => !!op).map((op) => {
                    return [contextKey, 'eq', this.quoteString(op)].join(' ');
                });
                return this.glue(stmts, 'or');
            },
            __bygroupid: (operand) => {
                return ['bygroupid(', operand, ')'].join('');
            },
            __has: (operand) => {
                return ['has(', operand, ')'].join('');
            }
        };
    }
    buildQuery(query) {
        const q = [];
        const filter = this.buildQueryFilter(query.__filter || query);
        const orderBy = this.buildQueryOrderby(query.__orderby);
        if (filter) {
            q.push(['$filter=(', filter, ')'].join(''));
        }
        if (orderBy) {
            q.push(['$orderby=', orderBy].join(''));
        }
        return q.join(' ');
    }
    buildQueryFilter(queryObj, _queryKey, _glueType) {
        const queryKey = _queryKey || null;
        const glueType = _glueType || 'and';
        const q = [];
        if (Array.isArray(queryObj)) {
            queryObj.forEach((qObj) => {
                const _q = this.buildQueryFilter(qObj, null, glueType);
                if (_q) {
                    q.push(_q);
                }
            });
        }
        else {
            let _q;
            Object.keys(queryObj).forEach((k) => {
                if (this.operatorFns[k] !== undefined) {
                    _q = this.operatorFns[k](queryObj[k], queryKey);
                    if (_q) {
                        q.push(_q);
                    }
                }
                else {
                    _q = this.operatorFns.__eq(queryObj[k], k);
                    if (_q) {
                        q.push(_q);
                    }
                }
            });
        }
        return this.glue(q, glueType);
    }
    buildQueryOrderby(query) {
        const o = [];
        if (query) {
            query.forEach((q) => {
                Object.keys(q).forEach((k) => {
                    if (q[k] !== 0) {
                        o.push([k, q[k] > 0 ? 'asc' : 'desc'].join(' '));
                    }
                });
            });
        }
        return o.join(',');
    }
    glue(stmts, type) {
        return ((stmts.length > 1) ? (['(', stmts.join(`) ${type} (`), ')'].join('')) : (stmts[0]));
    }
    quoteString(s) {
        return typeof s === 'string' ? ['\'', s, '\''].join('') : s;
    }
}
//# sourceMappingURL=QueriesUtil.js.map